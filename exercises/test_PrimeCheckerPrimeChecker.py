# ********RoostGPT********
"""
Test generated by RoostGPT for test python-test using AI Type Open AI and AI Model gpt-4o

ROOST_METHOD_HASH=prime_checker_6095e5e151
ROOST_METHOD_SIG_HASH=prime_checker_2148bd88fd


Scenario 1: Validate Correct Detection of Prime Numbers
Details:
  TestName: test_prime_numbers_detection
  Description: Verify that the function correctly identifies prime numbers within a given list.
Execution:
  Arrange: Prepare a list of known prime numbers and non-prime numbers.
  Act: Invoke the prime_checker function with the prepared list.
  Assert: Check if the returned list contains only the known prime numbers.
Validation:
  It is essential to confirm that the function can accurately detect prime numbers, which is its primary purpose.

Scenario 2: Handle an Empty List
Details:
  TestName: test_empty_list
  Description: Ensure that the function returns an empty list when given an empty list as input.
Execution:
  Arrange: Prepare an empty list.
  Act: Invoke the prime_checker function with the empty list.
  Assert: Verify that the result is an empty list.
Validation:
  The function should gracefully handle edge cases, such as an empty input list, and return an appropriate result.

Scenario 3: Handle List with No Prime Numbers
Details:
  TestName: test_no_prime_numbers
  Description: Ensure that the function returns an empty list when no prime numbers are present in the input list.
Execution:
  Arrange: Prepare a list containing only non-prime numbers.
  Act: Invoke the prime_checker function with the non-prime list.
  Assert: Verify that the result is an empty list.
Validation:
  The function should correctly handle cases where no prime numbers are present in the input list.

Scenario 4: Handle List with One Element Being a Prime Number
Details:
  TestName: test_single_prime_number
  Description: Verify that the function correctly identifies a single prime number in a list.
Execution:
  Arrange: Prepare a list with one prime number.
  Act: Invoke the prime_checker function with the single-element list.
  Assert: Check if the returned list contains the single prime number.
Validation:
  The function should accurately identify a prime number even if it is the only element in the list.

Scenario 5: Handle List with One Element Being a Non-Prime Number
Details:
  TestName: test_single_non_prime_number
  Description: Ensure that the function returns an empty list when given a single non-prime number.
Execution:
  Arrange: Prepare a list with one non-prime number.
  Act: Invoke the prime_checker function with the single-element list.
  Assert: Verify that the result is an empty list.
Validation:
  The function should correctly identify and exclude a non-prime number even if it is the only element in the list.

Scenario 6: Validate Function with Large Prime Numbers
Details:
  TestName: test_large_prime_numbers
  Description: Verify that the function correctly identifies large prime numbers.
Execution:
  Arrange: Prepare a list containing large prime and non-prime numbers.
  Act: Invoke the prime_checker function with the list of large numbers.
  Assert: Check if the returned list contains only the large prime numbers.
Validation:
  The function should handle large numbers efficiently and accurately detect prime numbers among them.

Scenario 7: Validate Function with Repeated Prime and Non-Prime Numbers
Details:
  TestName: test_repeated_numbers
  Description: Ensure that the function correctly processes lists with repeated prime and non-prime numbers.
Execution:
  Arrange: Prepare a list with repeated instances of prime and non-prime numbers.
  Act: Invoke the prime_checker function with the repeated numbers list.
  Assert: Verify that the returned list contains only the repeated prime numbers.
Validation:
  The function should handle lists with repeated numbers correctly and return the appropriate prime numbers.

Scenario 8: Validate Function with Negative Numbers and Zero
Details:
  TestName: test_negative_and_zero
  Description: Ensure that the function excludes negative numbers and zero from the prime numbers list.
Execution:
  Arrange: Prepare a list containing negative numbers, zero, and some positive numbers.
  Act: Invoke the prime_checker function with the mixed list.
  Assert: Verify that the result excludes negative numbers and zero.
Validation:
  The function should correctly exclude non-positive numbers from consideration as prime numbers.

Scenario 9: Validate Function with Consecutive Numbers
Details:
  TestName: test_consecutive_numbers
  Description: Verify that the function correctly identifies prime numbers in a list of consecutive numbers.
Execution:
  Arrange: Prepare a list of consecutive numbers from a given range.
  Act: Invoke the prime_checker function with the consecutive numbers list.
  Assert: Check if the returned list contains only the prime numbers from the range.
Validation:
  The function should accurately identify prime numbers in a sequence of consecutive numbers.

Scenario 10: Validate Function with Mixed Number Types
Details:
  TestName: test_mixed_number_types
  Description: Ensure that the function correctly identifies prime numbers in a list with mixed number types (integers and floats).
Execution:
  Arrange: Prepare a list containing integers and floats, both prime and non-prime.
  Act: Invoke the prime_checker function with the mixed list.
  Assert: Verify that the result contains only the integer prime numbers.
Validation:
  The function should handle mixed number types correctly and identify prime numbers accurately.
"""

# ********RoostGPT********
import pytest
from exercises.prime_checker import prime_checker

class Test_PrimeCheckerPrimeChecker:
    
    # Scenario 1: Validate Correct Detection of Prime Numbers
    # TestName: test_prime_numbers_detection
    # Description: Verify that the function correctly identifies prime numbers within a given list.
    @pytest.mark.positive
    def test_prime_numbers_detection(self):
        # Arrange
        test_numbers = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
        expected_primes = [2, 3, 5, 7, 11]
        # Act
        result = prime_checker(test_numbers)
        # Assert
        assert result == expected_primes

    # Scenario 2: Handle an Empty List
    # TestName: test_empty_list
    # Description: Ensure that the function returns an empty list when given an empty list as input.
    @pytest.mark.edge
    def test_empty_list(self):
        # Arrange
        test_numbers = []
        expected_primes = []
        # Act
        result = prime_checker(test_numbers)
        # Assert
        assert result == expected_primes

    # Scenario 3: Handle List with No Prime Numbers
    # TestName: test_no_prime_numbers
    # Description: Ensure that the function returns an empty list when no prime numbers are present in the input list.
    @pytest.mark.negative
    def test_no_prime_numbers(self):
        # Arrange
        test_numbers = [4, 6, 8, 9, 10, 12]
        expected_primes = []
        # Act
        result = prime_checker(test_numbers)
        # Assert
        assert result == expected_primes

    # Scenario 4: Handle List with One Element Being a Prime Number
    # TestName: test_single_prime_number
    # Description: Verify that the function correctly identifies a single prime number in a list.
    @pytest.mark.positive
    def test_single_prime_number(self):
        # Arrange
        test_numbers = [7]
        expected_primes = [7]
        # Act
        result = prime_checker(test_numbers)
        # Assert
        assert result == expected_primes

    # Scenario 5: Handle List with One Element Being a Non-Prime Number
    # TestName: test_single_non_prime_number
    # Description: Ensure that the function returns an empty list when given a single non-prime number.
    @pytest.mark.negative
    def test_single_non_prime_number(self):
        # Arrange
        test_numbers = [4]
        expected_primes = []
        # Act
        result = prime_checker(test_numbers)
        # Assert
        assert result == expected_primes

    # Scenario 6: Validate Function with Large Prime Numbers
    # TestName: test_large_prime_numbers
    # Description: Verify that the function correctly identifies large prime numbers.
    @pytest.mark.regression
    def test_large_prime_numbers(self):
        # Arrange
        test_numbers = [101, 103, 107, 109, 110, 113, 117]
        expected_primes = [101, 103, 107, 109, 113]
        # Act
        result = prime_checker(test_numbers)
        # Assert
        assert result == expected_primes

    # Scenario 7: Validate Function with Repeated Prime and Non-Prime Numbers
    # TestName: test_repeated_numbers
    # Description: Ensure that the function correctly processes lists with repeated prime and non-prime numbers.
    @pytest.mark.regression
    def test_repeated_numbers(self):
        # Arrange
        test_numbers = [2, 2, 4, 4, 5, 5, 6, 6]
        expected_primes = [2, 2, 5, 5]
        # Act
        result = prime_checker(test_numbers)
        # Assert
        assert result == expected_primes

    # Scenario 8: Validate Function with Negative Numbers and Zero
    # TestName: test_negative_and_zero
    # Description: Ensure that the function excludes negative numbers and zero from the prime numbers list.
    @pytest.mark.security
    def test_negative_and_zero(self):
        # Arrange
        test_numbers = [-10, -3, 0, 1, 2, 3]
        expected_primes = [2, 3]
        # Act
        result = prime_checker(test_numbers)
        # Assert
        assert result == expected_primes

    # Scenario 9: Validate Function with Consecutive Numbers
    # TestName: test_consecutive_numbers
    # Description: Verify that the function correctly identifies prime numbers in a list of consecutive numbers.
    @pytest.mark.regression
    def test_consecutive_numbers(self):
        # Arrange
        test_numbers = list(range(1, 20))
        expected_primes = [2, 3, 5, 7, 11, 13, 17, 19]
        # Act
        result = prime_checker(test_numbers)
        # Assert
        assert result == expected_primes

    # Scenario 10: Validate Function with Mixed Number Types
    # TestName: test_mixed_number_types
    # Description: Ensure that the function correctly identifies prime numbers in a list with mixed number types (integers and floats).
    @pytest.mark.security
    def test_mixed_number_types(self):
        # Arrange
        test_numbers = [2, 3.5, 4, 5.0, 6.1, 7]
        expected_primes = [2, 7]
        # Act
        result = prime_checker(test_numbers)
        # Assert
        assert result == expected_primes
